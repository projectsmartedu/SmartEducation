/**
 * Text Extraction Service
 * Extracts text content from various file formats
 * Modular component for content extraction
 */

const pdfParse = require('pdf-parse');

class TextExtractionService {
  /**
   * Extract text from PDF buffer
   * @param {Buffer} buffer - PDF file buffer
   * @returns {Promise<string>} - Extracted text
   */
  async extractFromPDF(buffer) {
    try {
      // pdf-parse v1.x returns an object with { text }
      const result = await pdfParse(buffer);
      return this.cleanText(result.text);
    } catch (error) {
      console.error('Error extracting text from PDF:', error);
      throw new Error(`PDF extraction failed: ${error.message}`);
    }
  }

  /**
   * Extract text from plain text/notes
   * @param {string} text - Raw text content
   * @returns {string} - Cleaned text
   */
  extractFromText(text) {
    return this.cleanText(text);
  }

  /**
   * Clean and normalize text
   * @param {string} text - Raw text
   * @returns {string} - Cleaned text
   */
  cleanText(text) {
    if (!text) return '';

    return text
      // Replace multiple whitespaces with single space
      .replace(/\s+/g, ' ')
      // Remove special characters but keep punctuation
      .replace(/[^\w\s.,!?;:'"()-]/g, ' ')
      // Remove multiple spaces again
      .replace(/\s+/g, ' ')
      // Trim
      .trim();
  }

  /**
   * Split text into chunks for embedding
   * @param {string} text - Full text content
   * @param {number} chunkSize - Maximum characters per chunk
   * @param {number} overlap - Overlap between chunks
   * @returns {string[]} - Array of text chunks
   */
  chunkText(text, chunkSize = 1000, overlap = 200) {
    if (!text || text.length === 0) {
      return [];
    }

    const chunks = [];
    const sentences = text.match(/[^.!?]+[.!?]+/g) || [text];
    
    let currentChunk = '';
    let currentLength = 0;

    for (const sentence of sentences) {
      const sentenceLength = sentence.length;

      if (currentLength + sentenceLength > chunkSize && currentChunk.length > 0) {
        chunks.push(currentChunk.trim());
        
        // Keep overlap from the end of current chunk
        const words = currentChunk.split(' ');
        const overlapWords = [];
        let overlapLength = 0;
        
        for (let i = words.length - 1; i >= 0 && overlapLength < overlap; i--) {
          overlapWords.unshift(words[i]);
          overlapLength += words[i].length + 1;
        }
        
        currentChunk = overlapWords.join(' ') + ' ';
        currentLength = currentChunk.length;
      }

      currentChunk += sentence + ' ';
      currentLength += sentenceLength + 1;
    }

    if (currentChunk.trim().length > 0) {
      chunks.push(currentChunk.trim());
    }

    return chunks;
  }

  /**
   * Get word count from text
   * @param {string} text - Text content
   * @returns {number} - Word count
   */
  getWordCount(text) {
    if (!text) return 0;
    return text.split(/\s+/).filter(word => word.length > 0).length;
  }

  /**
   * Get reading time estimate in minutes
   * @param {string} text - Text content
   * @param {number} wordsPerMinute - Reading speed
   * @returns {number} - Estimated minutes
   */
  getReadingTime(text, wordsPerMinute = 200) {
    const wordCount = this.getWordCount(text);
    return Math.ceil(wordCount / wordsPerMinute);
  }
}

module.exports = new TextExtractionService();
